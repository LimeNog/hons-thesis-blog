---
title: A Deep Learning Approach to Optimal Reinsurance under Rational Inattention
format: html
---

```{=html}
<style>
.mermaid-map {
  width: 90%;                  /* container width (adjust as needed) */
  max-width: 1200px;           /* optional max width */
  height: 500px;               /* container height */
  margin: 1rem auto;           /* center horizontally with some top/bottom space */
  overflow: hidden;            /* hide scrollbars */
  position: relative;
  border: 2px solid #333;      /* add border back */
  border-radius: 8px;          /* optional rounded corners */
  background-color: #f9f9f9;   /* optional background */
  display: flex;               /* stretch child */
  flex-direction: column;
}

.mermaid-map .mermaid {
  flex: 1;                     /* stretch Mermaid block */
}

.mermaid-map .mermaid svg {
  width: max-content !important;
  max-width: none !important;
  height: 100% !important;     /* fill container vertically */
  transform-origin: 0 0;
  cursor: grab;
  user-select: none;
  display: block;
}
</style>

```

```{=html}
<script>
function initMermaidMap(container) {
  const svg = container.querySelector("svg");
  if (!svg) return false;

  let scale = 1;
  let panX = 0;
  let panY = 0;
  let isPanning = false;
  let startX = 0;
  let startY = 0;

  function update() {
    svg.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
  }

  container.addEventListener("wheel", function(e) {
    e.preventDefault();

    const rect = container.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;

    const zoom = e.deltaY < 0 ? 1.1 : 0.9;
    const newScale = Math.min(Math.max(scale * zoom, 0.3), 4);

    panX = mx - (mx - panX) * (newScale / scale);
    panY = my - (my - panY) * (newScale / scale);

    scale = newScale;
    update();
  }, { passive: false });

  container.addEventListener("mousedown", function(e) {
    isPanning = true;
    startX = e.clientX - panX;
    startY = e.clientY - panY;
  });

  window.addEventListener("mousemove", function(e) {
    if (!isPanning) return;
    panX = e.clientX - startX;
    panY = e.clientY - startY;
    update();
  });

  window.addEventListener("mouseup", function() {
    isPanning = false;
  });

  update();
  return true;
}

window.addEventListener("load", function () {
  document.querySelectorAll(".mermaid-map").forEach(container => {
    const timer = setInterval(() => {
      if (initMermaidMap(container)) {
        clearInterval(timer);
      }
    }, 200);
  });
});
</script>
```

:::: column-page
::: mermaid-map
```{mermaid}
graph LR

ins[Insurance] --> reins[Reinsurance]
reins --> cl_mod[Cramer-Lundberg model]
rv[Random variables] --> stoch[Stochastic processes]
rv --> clt[Central Limit Theorem]
stoch --> pp[Poisson processes]
stoch --> bm[Brownian motion]
stoch --> fclt[Functional Central Limit Theorem]
clt --> fclt
pp --> cl_mod
bm --> sde[Stochastic Differential Equations]
sde --> bs_mod[Black-Scholes model]
sde --> diff_approx_cl[Diffusion approximation of CL aggregate claims]
cl_mod --> diff_approx_cl
fclt --> diff_approx_cl
bs_mod --> surp[Insurer and reinsurer surplus processes]
diff_approx_cl --> surp

stackel[Stackelberg differential game] --> inc[incomplete]
e_util[Expected utility] --> inc
k_filter[Kalman filtering] --> inc
ri[Rational inattention] --> inc
dl[Deep Learning] --> inc
entropy[<a href='entropy.html'>Entropy</a>] --> inc

click ins "post2.html" "Go to Start page"
```
:::
::::
